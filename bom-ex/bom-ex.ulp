//////////////////////////////////////////////////////////////////////////////
//
// BOM-EX ENHANCED BILL OF MATERIALS
//
// Copyright (C) 2010-2011, Robert E. Starr (http://www.bobstarr.net)
//
// Additional enhancements by Malcolm Miranda
//
// REVISION HISTORY:
//
// 1.07 RES 04/01/10  Initial Release
//
// 1.08 RES 04/07/10  Added auto-load database support from global attribute.
//                    If global attr 'DATABASE' exists we use the value
//                    as the file pathname and load the database at startup.
//
// 1.09 RES 04/14/10  Minor user interface changes to save space.
//
// 1.10 RES 04/14/10  Added support for DNP attribute. Part ID names will
//                    have (DNP) appended if the DNP attribute is set for
//                    on the part.
//
// 1.11 RES 04/16/10  Added logic from part num manager to allow importing,
//                    editing and updating of part numbers from within
//                    BOM viewer. In list by name view part numbers are
//                    editable and in list by value mode database parts may
//                    be edited.
//
// 1.12 RES 04/19/10  Added logic to prevent DNP parts from appearing
//                    in the order export files.
//
// 1.13 RES 04/21/10  Fixed bug causing multi-gate parts on different sheets
//                    to appear multiple times in the bom list views.
//
// 1.14 RES 04/22/10  Changed database column heading names and fixed bug
//                    when exporting order files and a blank partname was
//                    was encountered.
//
// 1.15 RES 04/23/10  Fixed problem with BOM-ENTRY part-id missing.
//                    Added logic to include addtional devices that
//                    have no package but need to be included in the BOM
//                    for ordering purposes (e.g. jumper blocks, etc).
//
// 1.16 RES 05/03/10  Added new dlgSelectionChanged() logic to part no
//                    pick list dialog. Part number is updated when the
//                    user clicks a different item. Double clicking accepts
//                    the current item selected and closes the dialog.
//
// 1.17 RES 08/30/10  Added build qty options for digikey & generic order
//                    export files. Fixed problem with generic CSV export
//                    where DNP parts were being omitted.
//
// 1.18 RES 09/04/10  Added options to edit build qty's for order export.
//
// 1.19 RES 10/13/10  Fixed quantity calculations for parts with DNP
//                    attributes for part order exports.
//
// 1.20 RES 11/15/10  Added logic to automatically use the parts id's for
//                    the customer reference if the Customer Ref column is
//                    not provided in the Digikey export function.
//
// 1.21 RES 11/29/10  Modified SaveBOM to append ListByPartID or ListByPartValue
//                    to the filename depending on the current list view mode.
//
// 1.22 RES 02/13/11  Added export part number only option in export dialog.
// 
// 1.23 MM  02/25/11  Set part# enhancment allows setting groups of part
//                    numbers in list by value mode!
// 
// 1.24 RES  02/26/11 Added database editing functionality and ability to 
//                    enter a new part VALUE also when assigning part numbers.
// 
// 1.25 RES  02/26/11 Added export part numbers options to specify all part
//                    numbers or part numbers assigned but not found in the
//                    database. Changed sort orders for exporting so data
//                    appears in a more logical order.
//////////////////////////////////////////////////////////////////////////////
//
// THIS PROGRAM IS PROVIDED AS IS AND WITHOUT WARRANTY OF ANY KIND,
// EXPRESSED OR IMPLIED. IF YOU DON'T LIKE IT, DON'T USE IT!
//
//////////////////////////////////////////////////////////////////////////////

#require 5.1000

#usage "en: <b>Export a Bill Of Material</b> - v1.25\n"
           "<p>"
           "Generates a project's <i>Bill Of Material</i>."
           "<p>"
           "A database with additional information like order codes, manufacturers "
           "or prices can be created and managed."
           "<p>"
           "This version uses ATRRIBUTE[PARTNO] for the database key. Thus, all parts "
           "in a schematic should have an attribute of 'PARTNO' with the mfg part number. "
           "Additionally the PARTNO attribute is used as the lookup key in the part database."
           "<p>"
           "<author>Author: support@cadsoft.de</author> "
           "<p>"
           "<author>Modifications by Bob Starr (rtzaudio@comcast.net)</author>",
       "de: <b>Stückliste exportieren</b>\n"
           "<p>"
           "Erzeugt die <i>Stückliste</i> (Bill Of Material) eines Projekts."
           "<p>"
           "Eine Datenbank mit zusätzlichen Informationen wie Bestellnummern, Herstellern "
           "oder Preisen kann angelegt und verwaltet werden."
           "<p>"
           "<author>Author: support@cadsoft.de</author> "
           "<p>"
           "<author>Modifications by Bob Starr (rtzaudio@comcast.net)</author>"

string HelpTextEN =
  "<b>HOW TO GENERATE A BILL OF MATERIALS</b>\n"
  "<p>\n"
  "<b>LIST TYPE</b>\n"
  "<p>\n"
  "The <i>Bill Of Materials</i> can be generated either as a list\n"
  "of parts (where every part is listed on a line of its own),\n"
  "or as a list of values, where all parts with the same value are grouped\n"
  "together in one line. Use the <b>List by</b> combo box to view the list\n"
  "by 'Parts' or 'Values'.\n"
  "<p>\n"
  "<b>Saving the Report</b>\n"
  "<p>\n"
  "The <b>Format</b> combo box sets the save report output to pure ASCII\n"
  "<b>Text</b> or <b>HTML</b> format. Click on the <b><u>S</u>ave BOM</b>\n"
  "button to save the report to disk. Click on the <b>Preview</b> button\n"
  "to see a preview of the report data that will be saved to disk.\n"
  "<p>\n"
  "<b>PART DATABASE</b>\n"
  "<p>\n"
  "You can pull in additional information about the used parts by loading\n"
  "a database file with the <b><u>L</u>oad</b> button.\n"
  "<p>\n"
  "A database file must consist of lines of text, each of which contains\n"
  "one record consisting of CSV (<u>C</u>omma <u>S</u>eparated <u>V</u>alues)\n"
  "or txt (<u>T</u>ab <u>S</u>eparated <u>V</u>alues) data.\n"
  "The very first line must contain a \"header\", which defines a unique name for\n"
  "each column, and the first column of every following line must contain\n"
  "a unique (non-empty) key for this record.\n"
  "<p>\n"
  "An example for a valid database file would be:\n"
  "<pre>\n"
  "  Key                OrderNo         Vendor   Price\n"
  "  GRM188R71H103KA01D 490-1512-2-ND   DigiKey  0.20\n"
  "  B140B-13-F         B140B-FDIDKR-ND DigiKey  0.20952\n"
  "</pre>\n"
  "Note that the columns are separated by a <b>tab</b> character (you may also\n"
  "use a semicolon (';') to separate the columns, but then you will have to make sure\n"
  "none of the data items contains a semicolon).\n"
  "<p>\n"
  "<b>ATTRIBUTES FOR BOM CONTROL</b>\n"
  "<p>\n"
  "The keys for looking up records in the database are built from the\n"
  "part <b>ATTRIBUTE[PARTNO]</b> field. Each part should have an attribute of <b>PARTNO</b> defined \n"
  "that is used to lookup in the database against the <b>Key</b> field described above.\n"
  "<p>\n"
  "The following part ATTRIBUTES are reckognized by the BOM processor:\n"
  "<pre>\n"
  " Attribute  Value          Description\n"
  " ---------------------------------------------------------------------------------\n"
  " PARTNO     [<i>MfgPartNum</i>]   Specifies mfg part number key in the database file.\n"
  " BOM        [EXCLUDE]      Excludes part from the BOM listing.\n"
  " DNP        [T/F]          Do not place identifier (T=true or F=false)\n"
  "</pre>\n"
  "<p>\n"
  "Addtionally the following special attribtues are reckognized and concatenated to the\n"
  "parts VALUE field during bom generation to list additional information for a part.\n"
  "In some cases a part with the same value and package will differ for tolerance, temp\n"
  "codes, etc. These additional attributes are concatenated to the part value field during\n"
  "BOM generation so the part is given a unique line item entry. NOTE this behavior can be\n"
  "overridden with the BOM[NOVALMOD] attribute described above. If the [NOVALMOD] flag is\n"
  "also specified, the original value field will be used as is for value key comparisions\n"
  "and the attribute modifiers below will not appear appended to the part value in the BOM"
  "\n"
  "<pre>\n"
  " Attribute   Description\n"
  " --------------------------------------------------------\n"
  " TOL         tolerance (1%, 5%, etc)\n"
  " TC          temp coefficient (caps, NPO, X7R, etc)\n"
  " VOLT        voltage rating (caps, etc)\n"
  " RATE        rating (watts, etc)\n"
  " COLOR       color (for leds, etc)\n"
  " LABEL       label (for buttons, switches, etc)\n"
  " TYPE        type field\n"
  " SIZE        package or other size code (0805, etc)\n"
  " LOAD        load field\n"
  " PLACE       place option text\n"
  " OPT         generic option text\n"
  "</pre>\n"
  "<p>\n"
  "<p>\n"
  "<b>CREATING A NEW DATABASE</b>\n"
  "<p>\n"
  "Click on the <b><u>N</u>ew</b> button to create a new database.\n"
  "You will get a dialog in which you can define the names of the column headers\n"
  "for your new database. The first column always contains the key for database\n"
  "lookups and can't be deleted (you can edit it, though, to give it a different\n"
  "name than the default \"Key\"). This first column will not be visible in the\n"
  "generated list, so you don't really need to worry about it.\n"
  "<p>\n"
  "<b>EXPORTING AN ORDER BOM</b>\n"
  "<p>\n"
  "You can export a BOM in Digi-Key BOM upload order format in CSV or TAB format.\n"
  "However, this feature requires that part database be in the following format\n"
  "with the exact column field names as shown below (less ticks):\n"
  "<p>\n"
  "<pre>\n"
  "Col   Field Name                  Description\n"
  "-------------------------------------------------------------------\n"
  " 0    'Mfg Part Num'                PARTNUM key for schematic\n"
  " 1    'Mfg Name'                    Mfg name of the part\n"
  " 2    'VID'                         Vendor ID (eg 'DK'=Digikey)\n"
  " 3    'Vendor Part Num'             Specifies the vendor part number\n"
  " 4    'Description'                 Optional - part description\n"
  " 5    'Qty 1'                       First bulk order quantity  (optional)\n"
  " 6    'Qty 2'                       Second bulk order quantity  (optional)\n"
  " 7    'Qty 3'                       Third bulk order quantity (optional)\n"
  " 8    'Customer Ref'                Customer reference number\n"
  "</pre>\n"
  "<p>\n"
  "Note that the 'Qty' fields are optional and will be calculated\n"
  "automatically if not specified when exporting order files.\n"
  "<p>\n"
  "<b>EDITING THE DATABASE</b>\n"
  "<p>\n"
  "If you have loaded a database you can either double click on a line\n"
  "in the list, or select a line and press Enter (or click on the <b>Edit</b>\n"
  "button) to bring up a dialog in which you can edit the database entry\n"
  "for this part. If the database has been modified you will be asked if\n"
  "you want to save it before leaving the program or loading a new database.\n"
  "<p>\n"
  ;

string HelpTextDE =
  "<b>Erzeugen der Stückliste</b>\n"
  "<p>\n"
  "<b>Listen-Typ</b>\n"
  "<p>\n"
  "Die <i>Stückliste</i> kann entweder als Liste der Bauteile generiert werden\n"
  "(wobei jedes Bauteil in einer eigenen Zeile aufgeführt wird),\n"
  "oder als Liste der Werte, wobei alle Bauteile mit dem gleichen Wert in einer Zeile\n"
  "zusammengefasst werden. Mit den Radio-Buttons <b><u>B</u>auteile</b> und <b><u>W</u>erte</b>\n"
  "kann zwischen den beiden Listen-Typen gewählt werden.\n"
  "<p>\n"
  "<b>Ausgabeformat</b>\n"
  "<p>\n"
  "Wählen Sie zwischen reinem ASCII-<b><u>T</u>ext</b> oder <b><u>H</u>TML</b>-Format.\n"
  "<p>\n"
  "<b>Datenbank</b>\n"
  "<p>\n"
  "Mit dem <b><u>L</u>oad</b>-Button können Sie eine Datenbankdatei mit zusätzlichen\n"
  "Informationen über die Bauteile laden.\n"
  "<p>\n"
  "Eine Datenbankdatei besteht aus Textzeilen, von denen jede einen Datensatz bestehend\n"
  "aus CSV (<u>C</u>omma <u>S</u>eparated <u>V</u>alues) oder\n"
  "TXT (<u>T</u>ab <u>S</u>eparated <u>V</u>alues) Daten enthält.\n"
  "Die erste Zeile muß eine Titelzeile enthalten, welche einen eindeutigen Namen\n"
  "für jede Spalte definiert, und die erste Spalte jeder folgenden Zeile muß einen eindeutigen\n"
  "(nicht leeren) Schlüssel für diesen Datensatz enthalten.\n"
  "<p>\n"
  "Beispiel für eine gültige Datenbankdatei:\n"
  "<pre>\n"
  "Key                OrderNo         Vendor   Price\n"
  "GRM188R71H103KA01D 490-1512-2-ND   DigiKey  0.20\n"
  "B140B-13-F         B140B-FDIDKR-ND DigiKey  0.20952\n"
  "</pre>\n"
  "Beachten Sie, daß die Spalten durch <b>Tabulator</b>-Zeichen getrennt sind (Sie können\n"
  "auch das Semikolon-Zeichen (';') als Trennzeichen verwenden, wobei Sie dann aber sicherstellen\n"
  "müssen, daß keines der Datenfelder ein Semikolon enthält).\n"
  "Die Schlüssel für die Suche nach Datensätzen in der Datenbank werden aus den Werten der\n"
  "Bauteile gebildet. Hat das Device eines Bauteils \"value on\" gesetzt, so bedeutet dies, daß\n"
  "der Benutzer einen individuellen Wert für dieses Bauteil (zum Beispiel einen Widerstand)\n"
  "angeben muß. In einem solchen Fall besteht der Schlüssel aus dem Device-Namen und dem vom\n"
  "Benutzer angegebenen Wert, getrennt durch einen Doppelpunkt (':'). Hat das\n"
  "Device \"value off\", so wird nur der Name des Devices als Schlüssel genommen (hat der\n"
  "Benutzer den Wert eines solchen Bauteils editiert und darauf bestanden, ihn zu verändern,\n"
  "so wird der veränderte Wert genommen).\n"
  "<p>\n"
  "<b>Neue Datenbank anlegen</b>\n"
  "<p>\n"
  "Klicken Sie auf <b><u>N</u>eu</b> um eine neue Datenbank anzulegen.\n"
  "In einem Dialog können Sie dann die Namen der Datenfelder Ihrer neuen Datenbank\n"
  "festlegen. Das erste Feld enthält immer den Schlüssel für den Datenbank-Zugriff\n"
  "und kann nicht gelöscht werden (es kann aber editiert werden um ihm einen anderen Namen\n"
  "als den Standardwert \"Key\" zu geben). Dieses erste Feld wird in der generierten Liste\n"
  "nicht sichtbar sein, Sie brauchen sich also keine Gedanken darüber zu machen.\n"
  "<p>\n"
  "<b>Bearbeiten der Datenbank</b>\n"
  "<p>\n"
  "Wenn Sie eine Datenbank geladen haben können Sie entweder auf eine Zeile in der\n"
  "Liste doppelklicken, oder eine Zeile auswählen und die Eingabetaste drücken (oder auf <b>Bearbeiten</b>\n"
  "klicken) um einen Dialog zu erhalten in dem Sie den Datenbank-Eintrag für dieses Bauteil\n"
  "bearbeiten können. Wurde die Datenbank verändert so werden Sie vor dem Verlassen des Programms\n"
  "oder vor dem Laden einer neuen Datenbank gefragt, ob Sie diese abspeichern wollen.\n"
  "<p>\n"
  "<b>Betrachten der Ausgabe</b>\n"
  "<p>\n"
  "Klicken Sie auf <b><u>V</u>orschau</b> um eine Vorschau der Ausgabe zu erhalten.\n"
  "<p>\n"
  "<b>Speichern der Liste</b>\n"
  "<p>\n"
  "Klicken Sie auf <b><u>S</u>peichern</b> um die Liste abzuspeichern.\n"
  ;

string I18N[] = {
  "en\v"
  "de\v"
  ,
  "<hr><b>ERROR: No schematic!</b><p>\nThis program can only work in the schematic editor.\v"
  "<hr><b>FEHLER: Kein Schaltplan!</b><p>\nDieses Programm kann nur in einem Schaltplan verwendet werden.\v"
  ,
  "Part\tValue\tPartNo\tDevice\tPackage\tDescription\v"
  "Bauteil\tWert\tPartNo\tDevice\tPackage\tDescription\v"
  ,
  "Qty\tValue\tDevice\tParts\v"
  "Menge\tWert\tDevice\tBauteile\v"
  ,
  "Partlist exported from %s at %s\v"
  "Stückliste exportiert aus %s am %s\v"
  ,
  "Bill Of Material - Preview\v"
  "Stückliste - Vorschau\v"
  ,
  "-Close\v"
  "-Schließen\v"
  ,
  "Save Bill Of Material\v"
  "Stückliste speichern\v"
  ,
  "File '\v"
  "Datei '\v"
  ,
  "' exists\n\nOverwrite?\v"
  "' existiert\n\nÜberschreiben?\v"
  ,
  "+&Yes\v"
  "+&Ja\v"
  ,
  "-&No\v"
  "-&Nein\v"
  ,
  "&No\v"
  "&Nein\v"
  ,
  "Name already defined!\v"
  "Name ist bereits definiert!\v"
  ,
  " Header\v"
  " Spaltenüberschrift\v"
  ,
  "&Name:\v"
  "&Name:\v"
  ,
  "+OK\v"
  "+OK\v"
  ,
  "Name can't be empty!\v"
  "Name kann nicht leer sein!\v"
  ,
  "-Cancel\v"
  "-Abbrechen\v"
  ,
  "New Database\v"
  "Neue Datenbank\v"
  ,
  "&Headers\v"
  "&Spaltenüberschriften\v"
  ,
  "Edit\v"
  "Bearbeiten\v"
  ,
  "&Add\v"
  "&Hinzufügen\v"
  ,
  "New\v"
  "Neu\v"
  ,
  "&Del\v"
  "&Löschen\v"
  ,
  "Can't delete the \"Key\" header!\n\nUse \"Edit\" to change it.\v"
  "Die Spaltenüberschrift \"Key\" kann nicht gelöscht werden!\n\nBenutzen Sie \"Bearbeiten\" um sie zu ändern.\v"
  ,
  "&Edit\v"
  "&Bearbeiten\v"
  ,
  "Edit\v"
  "Bearbeiten\v"
  ,
  "Please add at least one header!\v"
  "Bitte fügen Sie mindestens eine Spaltenüberschrift hinzu!\v"
  ,
  "Choose database file\v"
  "Datenbankdatei auswählen\v"
  ,
  "Database files (*.txt *.csv);;All files (*)\v"
  "Datenbankdateien (*.txt *.csv);;Alle Dateien (*)\v"
  ,
  "Save database file\v"
  "Datenbankdatei speichern\v"
  ,
  "Database files (*\v"
  "Datenbankdateien (*\v"
  ,
  ");;All files (*)\v"
  ");;Alle Dateien (*)\v"
  ,
  "Edit Database\v"
  "Datenbank bearbeiten\v"
  ,
  "Please select a list entry first!\v"
  "Bitte wählen Sie erst einen Listeneintrag aus!\v"
  ,
  "Please load a database file first!\v"
  "Bitte Laden Sie zuerst eine Datenbankdatei!\v"
  ,
  "Database has been modified\n\nSave?\v"
  "Die Datenbank wurde verändert\n\nSpeichern?\v"
  ,
  "Bill Of Material - Help\v"
  "Stückliste - Hilfe\v"
  ,
  "Bill Of Material\v"
  "Stückliste\v"
  ,
  "Database:\v"
  "Datenbank:\v"
  ,
  "&Load\v"
  "&Laden\v"
  ,
  "&New\v"
  "&Neu\v"
  ,
  "List type\v"
  "Listen-Typ\v"
  ,
  "&Parts\v"
  "&Bauteile\v"
  ,
  "&Values\v"
  "&Werte\v"
  ,
  "Output format\v"
  "Ausgabeformat\v"
  ,
  "&Text\v"
  "&Text\v"
  ,
  "&HTML\v"
  "&HTML\v"
  ,
  "+Edit\v"
  "+Bearbeiten\v"
  ,
  "Vie&w\v"
  "&Vorschau\v"
  ,
  "&Save...\v"
  "&Speichern...\v"
  ,
  "H&elp\v"
  "H&ilfe\v"
  };

//////////////////////////////////////////////////////////////////////////////
//

string strVersion = "1.25";

int nPartCount;

numeric string Lines[];

int PartSheet[];
int PartDNP[];

numeric string PartRef[], PartName[], PartVal[], PartAttr[], PartNum[],
               PartDev[], PartPkg[], PartDesc[];

numeric string PartValSave[];

int Selected;

enum { ltParts, ltValues };     // List Types
enum { ofText, ofHTML };        // Output Formats

int ListType            = 0;
int OutputFormat        = 0;

string DefaultFileName;

int DatabaseRecCount;
string Database[];
string DatabaseFields[];

char DatabaseSeparator  = '\t';

string DatabaseFilename;

int DatabaseModified    = 0;
int PartNumModified     = 0;
int PartNumPicked       = 0;

char ValueSeparator     = ':';

string ConfigFilePath;
string ConfigFileName   = "bom-ex.cfg";

string nullKey          = "*";
string dnpSuffix        = "(DNP)";

int BldQty1             = 1;    // qty1 specifies qty to build 1 unit
int BldQty2             = 5;    // qty2 specifies qty to build 10 units
int BldQty3             = 25;   // qty3 specifies qty to build 25 units

//////////////////////////////////////////////////////////////////////////////
// Some Helper Functions

int Language = strstr(I18N[0], language()) / 3;

string tr(string s)
{
    // FIX: ONLY SUPPORT ENGLISH FOR NOW - DE TEXT TRANSLATION NEEDED!
    //string t = lookup(I18N, s, Language, '\v');
    //return t ? t : s;
    return s;
}

string StripWhiteSpace(string s)
{
    while (s && isspace(s[0]))
        s = strsub(s, 1);
    while (s && isspace(s[strlen(s) - 1]))
        s = strsub(s, 0, strlen(s) - 1);
    return s;
}

int isquote(char c)
{
    return (c == '"') ? 1 : 0;
}

string TrimQuotes(string s)
{
    while (s && isquote(s[0]))
        s = strsub(s, 1);
    while (s && isquote(s[strlen(s) - 1]))
        s = strsub(s, 0, strlen(s) - 1);
    return s;
}

string TrimDNPSuffix(string s)
{
    // we have to strip off any (DNP) suffix from the part name
    int lensuffix = strlen(dnpSuffix);
    int lenstr    = strlen(s);
    if (lenstr > lensuffix)
    {
        if (strstr(s, dnpSuffix) > 0)
            s = strsub(s, 0, lenstr - lensuffix);
    }
    return s;
}

int PartSearch(string partname)
{
    for (int i=0; i < nPartCount; i++)
    {
        if (PartName[i] == partname)
            return i;
    }
    return -1;
}

//////////////////////////////////////////////////////////////////////////////
// Here we're checking for a specific set of known attributes that
// we will allow to display in the Attributes column of the BOM. Any other
// part attributes we will ignore for now.

int IsKnownAttribute(string attrname)
{
    string names = "TOL:TEMP:TC:VOLT:VOLTAGE:RATE:RATING:COLOR:LABEL:TYPE:SIZE:LOAD:PLACE";
    string a[];
    int n = strsplit(a, names, ':');
    int i;
    for (i=0; i < n; i++)
    {
        if (attrname == a[i])
            return 1;
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// Here we're checking for a specific device names that have no associated
// package that we want added to the BOM listing also. We don't add any
// devices without packages to listing except those listed here.

int IsKnownDevice(string devname)
{
    string names = "BOM-ENTRY:JUMPER:JUMP-A:JUMP-B:JUMP-Q";
    string a[];
    int n = strsplit(a, names, ':');
    int i;
    for (i=0; i < n; i++)
    {
        if (devname == a[i])
            return 1;
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// Collect all part data for the BOM and process and handle any attribute
// modifiers found for the part.

void CollectPartData(void)
{
    nPartCount = 0;

    schematic(SCH)
    {
        SCH.sheets(S)
        {
            S.parts(P)
            {
                if ((P.device.package) || IsKnownDevice(P.device.name))
                {
                    int exclude = 0;
                    int dnp = 0;

                    // PART NUMBER CANNOT BE EMPTY FOR LIST BY VALUE SORT!
                    string partnum = nullKey;
                    string val     = P.value;
                    string attrs   = "";

                    P.attributes(A)
                    {
                        if ((A.name == "PARTNUM") || (A.name == "PARTNO"))
                        {
                            partnum = A.value;
                        }
                        else if (A.name == "BOM")
                        {
                            // Exclude part from BOM?
                            if (A.value == "EXCLUDE")
                                exclude = 1;
                        }
                        else if (A.name == "DNP")
                        {
                            // Exclude part from BOM?
                            if ((A.value == "T") || (A.value != "1"))
                                dnp = 1;
                        }
                        else
                        {
                            if (IsKnownAttribute(A.name))
                            {
                                if (strlen(attrs))
                                    attrs += "/";
                                attrs += A.value;
                            }
                        }
                    }

                    if (!exclude)
                    {
                        // We have to check to make sure the part has not already been added
                        // since it's possible a multi-gate part can appear on multiple sheets.
                        //
                        // In this case we only need to update the attributes on the first
                        // instance encountered for the attributes update process.

                        if (lookup(PartName, P.name, 0))
                            continue;

                        //numeric string ref;
                        //sprintf(ref, "%3d", nPartCount+1);

                        PartSheet[nPartCount] = S.number;
                        //PartRef[nPartCount]   = ref;
                        PartName[nPartCount]  = P.name;
                        PartVal[nPartCount]   = val;
                        PartValSave[nPartCount]  = val;
                        PartAttr[nPartCount]  = attrs;
                        PartNum[nPartCount]   = partnum;
                        PartDev[nPartCount]   = P.device.name;
                        PartPkg[nPartCount]   = (P.device.package) ? P.device.package.name : "*";
                        PartDesc[nPartCount]  = P.device.headline;
                        PartDNP[nPartCount]   = dnp;

                        nPartCount++;
                    }
                }
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//

string DatabaseHeader(void)
{
    string s;

    if (Database[0])
    {
        string a[];
        int n = strsplit(a, Database[0], DatabaseSeparator);
        int i;

        for (i = 1; i < n; i++)
        {
            s += "\t" + a[i];
            DatabaseFields[i - 1] = a[i];
        }

        DatabaseFields[i - 1] = "";
    }
    return s;
}

//////////////////////////////////////////////////////////////////////////////
//

string DatabaseKey(int i)
{
    return PartNum[i];
}

string DatabaseLookup(string key, int f)
{
    string s;
    s = lookup(Database, key, DatabaseFields[f], DatabaseSeparator);
    if (!s || (s == DatabaseFields[f]))
        s = nullKey;
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Generate parts list in part name order

void GeneratePartList(void)
{
    int NumLines = 0;
    //XXX column sequence?

    //Lines[NumLines++] = tr("Ref\tPart\tValue\tAttributes\tPackage\tDescription\tPart Num") + DatabaseHeader();
    Lines[NumLines++] = tr("Part\tValue\tAttributes\tPackage\tDescription\tPart Num") + DatabaseHeader();

    for (int i=0; i < nPartCount; i++)
    {
        // append (DNP) suffix on part name if needed
        string partname;
        partname = PartName[i];
        if (PartDNP[i])
            partname += dnpSuffix;

        //Lines[NumLines] = PartRef[i] + "\t" + partname + "\t" + PartVal[i] + "\t" +
        //                  PartAttr[i] + "\t" + PartPkg[i] + "\t" + PartDesc[i] + "\t" + PartNum[i];

        Lines[NumLines] = partname + "\t" + PartVal[i] + "\t" +
                          PartAttr[i] + "\t" + PartPkg[i] + "\t" + PartDesc[i] + "\t" + PartNum[i];

        if (Database[0])
        {
            string key = DatabaseKey(i);

            for (int f = 0; DatabaseFields[f]; f++)
                Lines[NumLines] += "\t" + DatabaseLookup(key, f);

            Lines[NumLines] += "\t" + key; // hidden field!
        }
        NumLines++;
    }

    Lines[NumLines] = "";
}

//////////////////////////////////////////////////////////////////////////////
// Generate parts list in part value order

void GenerateValueList(void)
{
    int NumLines = 0;
    int Index[];

    //XXX column sequence?
    Lines[NumLines++] = tr("Qty\tValue\tPart Num\tPackage\tParts") + DatabaseHeader();

    //sort(nPartCount, Index, PartVal, PartNum, PartDev, PartName);
    // [RES125] - Changed sort order
    sort(nPartCount, Index, PartName, PartVal, PartPkg);
    
    for (int n1 = 0, n2 = 0; ++n2 <= nPartCount;)
    {
        int i1 = Index[n1];

        if (n2 < nPartCount)
        {
            int i2 = Index[n2];
            // check for same value but different partnum
            if ((PartVal[i1] == PartVal[i2]) && (PartDev[i1] == PartDev[i2]))
            {
                if (strlen(PartNum[i1]) && strlen(PartNum[i2]))
                {
                    if (PartNum[i1] == PartNum[i2])
                        continue;
                }
                else
                {
                    continue;
                }
            }
        }

        string Quantity;

        // Calculate the qty of parts needed to build one unit less any DNP parts.
        int uqty = n2 - n1;

        int nn1 = n1;
        int nn2 = n2;
        int ii1 = i1;

        for (;;)
        {
            // append (DNP) suffix on part name if needed
            if (PartDNP[ii1] && uqty)
                --uqty;

            if (++nn1 < nn2)
                ii1 = Index[nn1];
            else
                break;
        }

        sprintf(Quantity, "%d", uqty);
        Lines[NumLines] = Quantity + "\t" + PartVal[i1] + "\t" + PartNum[i1] + "\t" + PartPkg[i1] + "\t";

        for (;;)
        {
            // append (DNP) suffix on part name if needed
            string partname;
            partname = PartName[i1];
            if (PartDNP[i1])
                partname += dnpSuffix;

            Lines[NumLines] += partname;

            if (++n1 < n2)
            {
                i1 = Index[n1];
                Lines[NumLines] += ", ";
            }
            else
                break;
        }

        if (Database[0])
        {
            string key = DatabaseKey(i1);

            for (int f = 0; DatabaseFields[f]; f++)
                Lines[NumLines] += "\t" + DatabaseLookup(key, f);

            Lines[NumLines] += "\t" + key; // hidden field!
        }
        NumLines++;
    }
    Lines[NumLines] = "";
}

//////////////////////////////////////////////////////////////////////////////
//

void GenerateList(void)
{
    switch (ListType)
    {
    case ltParts:
        GeneratePartList();
        break;
    case ltValues:
        GenerateValueList();
        break;
    }
}

//////////////////////////////////////////////////////////////////////////////
//

string MakeListHeader(void)
{
    string s;
    schematic(SCH) sprintf(s, tr("BOM-EX v%s exported from %s at %s"), strVersion, SCH.name, t2string(time()));
    return s;
}

string MakeListText(void)
{
    int l, Width[];
    for (l = 0; Lines[l]; l++)
    {
        string a[];
        for (int n = strsplit(a, Lines[l], '\t'); n--;)
            Width[n] = max(Width[n], strlen(a[n]));
    }

    string List;
    List = MakeListHeader() + "\n\n";
    int numHeaders;

    for (l = 0; Lines[l]; l++)
    {
        string line, a[];
        int n = strsplit(a, Lines[l], '\t');
        if (l == 0)
            numHeaders = n;
        else
            n = numHeaders; // for the hidden key!
        for (int i = 0; i < n; i++)
        {
            string s;
            sprintf(s, "%s%-*s", line ? " " : "", Width[i], a[i]);
            line += s;
        }
        List += line + "\n";
    }
    return List;
}

string MakeListHTML(void)
{
    string List;
    List = "<b>" + MakeListHeader() + "</b>\n<p>\n";
    List += "<table>\n";
    int numHeaders;

    for (int l = 0; Lines[l]; l++)
    {
        List += "<tr>";
        string a[];
        int n = strsplit(a, Lines[l], '\t');

        if (l == 0)
            numHeaders = n;
        else
            n = numHeaders; // for the hidden key!

        for (int i = 0; i < n; i++)
        {
            if (l == 0)
                a[i] = "<b>" + a[i] + "</b>";
            List += "<td>" + a[i] + "</td>";
        }
        List += "</tr>\n";
    }
    List += "</table>\n";
    return List;
}

string MakeList(void)
{
    switch (OutputFormat)
    {
    case ofText:
        return MakeListText();
        break;
    case ofHTML:
        return MakeListHTML();
        break;
    }
    return "";
}

void ViewList(void)
{
    dlgDialog(tr("Bill Of Material - Preview"))
    {
        string s = MakeList();
        if (OutputFormat == ofText)
            s = "<pre>" + s + "</pre>";
        dlgHBoxLayout dlgSpacing(650);
        dlgHBoxLayout
        {
            dlgVBoxLayout dlgSpacing(300);
            dlgTextView(s);
        }
        dlgHBoxLayout
        {
            dlgStretch(1);
            dlgPushButton(tr("-Close")) dlgReject();
        }
    };
}

void SaveBOM(void)
{
    string fname;

    string ext = (OutputFormat == ofHTML) ? ".htm" : ".bom";

    string tmp;

    if (ListType==0)
        tmp = "_ListByParts" + ext;
    else
        tmp = "_ListByValues" + ext;

    schematic(SCH) fname = filesetext(SCH.name, tmp);

    fname = dlgFileSave(tr("Save Bill Of Material"), fname);

    if (fname)
    {
        string a[];
        if (!fileglob(a, fname) || dlgMessageBox(tr("File '") + fname + tr("' exists\n\nOverwrite?"), tr("+&Yes"), tr("-&No")) == 0)
        {
            output(fname, "wt")
            {
                printf("%s", MakeList()); // using "%s" to avoid problems if list contains any '%'
            }
        }
    }
}

int ReadDatabase(string fname)
{
    string data;
    if (fileread(data, fname) > 0)
    {
        DatabaseRecCount = strsplit(Database, data, '\n');
        DatabaseSeparator = (strchr(Database[0], '\t') > -1) ? '\t' : ';';
        return 1;
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// Create a new database

string Headers[];
int NumHeaders;
int SelectedHeader;

int NewDatabaseHeaderOk(string Name)
{
    for (int i = 0; i < NumHeaders; i++)
    {
        if (Name == Headers[i])
        {
            dlgMessageBox(tr("Name already defined!"));
            return 0;
        }
    }
    return 1;
}

void NewDatabaseEdit(string Title, string Name)
{
    int NewName = !Name;

    dlgDialog(Title + tr(" Header"))
    {
        dlgLabel(tr("&Name:"));
        dlgStringEdit(Name);

        dlgHBoxLayout
        {
            dlgStretch(1);
            dlgPushButton(tr("+OK"))
            {
                Name = StripWhiteSpace(Name);
                if (!NewName)
                {
                    if (Name == Headers[SelectedHeader] || NewDatabaseHeaderOk(Name))
                    {
                        Headers[SelectedHeader] = Name;
                        dlgAccept();
                    }
                }
                else if (Name)
                {
                    if (NewDatabaseHeaderOk(Name))
                    {
                        SelectedHeader = NumHeaders;
                        Headers[NumHeaders] = Name;
                        Headers[++NumHeaders] = "";
                        dlgAccept();
                    }
                }
                else
                {
                    dlgMessageBox(tr("Name can't be empty!"));
                }
            }
            dlgPushButton(tr("-Cancel")) dlgReject();
        }
    };
}

void NewDatabase(void)
{
    if (dlgMessageBox("Create a new part database file?", "+&Yes", "&No") > 0)
        return;
    
    DatabaseFilename = "";
    Database[0] = "";

    GenerateList();
    dlgRedisplay();

    Headers[0] = "Key";
    Headers[1] = "";
    NumHeaders = 1;
    SelectedHeader = -1;

    int result = dlgDialog(tr("New Database"))
    {
        dlgHBoxLayout
        {
            dlgVBoxLayout
            {
                dlgLabel(tr("&Headers"));
                dlgListBox(Headers, SelectedHeader) NewDatabaseEdit(tr("Edit"), Headers[SelectedHeader]);
            }
            dlgVBoxLayout
            {
                dlgPushButton(tr("&Add")) NewDatabaseEdit(tr("New"), "");
                dlgPushButton(tr("&Del"))
                {
                    if (SelectedHeader > 0)
                    {
                        for (int i = SelectedHeader; i < NumHeaders - 1; i++)
                            Headers[i] = Headers[i + 1];

                        Headers[--NumHeaders] = "";

                        if (SelectedHeader >= NumHeaders)
                            SelectedHeader = NumHeaders - 1;
                    }
                    else
                    {
                        dlgMessageBox(tr("Can't delete the \"Key\" header!\n\nUse \"Edit\" to change it."));
                    }
                }
                dlgPushButton(tr("&Edit"))
                {
                    if (SelectedHeader >= 0)
                        NewDatabaseEdit(tr("Edit"), Headers[SelectedHeader]);
                    else
                        dlgMessageBox(tr("Please select a list entry first!"));
                }
            }
        }

        dlgHBoxLayout
        {
            dlgStretch(1);
            dlgPushButton(tr("+OK"))
            {
                if (NumHeaders > 1)
                    dlgAccept();
                else
                    dlgMessageBox(tr("Please add at least one header!"));
            }
            dlgPushButton(tr("-Cancel")) dlgReject();
        }
    };

    if (result)
    {
        string sep;

        for (int i = 0; Headers[i]; i++)
        {
            Database[0] += sep + Headers[i];
            sep = "\t";
        }

        DatabaseSeparator = '\t';
        DatabaseModified = 1;

        GenerateList();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Load/Save/Edit database

void LoadDatabase(string fname)
{
    if (!strlen(fname))
        fname = dlgFileOpen(tr("Open database file"), ConfigFilePath, tr("Database files (*.txt *.csv);;All files (*)"));

    if (fname)
    {
        // write last path in file to remember for next start
        output(filedir(argv[0])+ConfigFileName, "wt") printf("%s", filedir(fname));

        ConfigFilePath = filedir(fname);

        if (ReadDatabase(fname))
        {
            DatabaseFilename = fname;

            GenerateList();

            DatabaseModified = 0;
        }
    }
}

int SaveDatabase(void)
{
    if (!DatabaseFilename)
    {
        string ext = (DatabaseSeparator == '\t') ? ".txt" : ".csv";
        DatabaseFilename = dlgFileSave(tr("Save database file"), "", tr("Database files (*") + ext + tr(");;All files (*)"));
        if (!DatabaseFilename)
            return 0;
        if (fileext(DatabaseFilename) != ext)
            DatabaseFilename += ext;
    }
    fileerror();
    output(DatabaseFilename, "wt")
    {
        for (int i = 0; Database[i]; i++)
            printf("%s\n", Database[i]);
    };
    return !fileerror();
}

void EditDatabaseEntry(string Key, int Entry)
{
    string Header[];
    string Data[];
    int Fields = strsplit(Header, Database[0], DatabaseSeparator);
    strsplit(Data, Database[Entry], DatabaseSeparator);

    if (!Data[0])
        Data[0] = Key;

    int result = dlgDialog(tr("Edit Database"))
    {
        dlgHBoxLayout dlgSpacing(400);

        dlgGridLayout
        {
            for (int f = 0; f < Fields; f++)
            {
                dlgCell(f, 0) dlgLabel(Header[f]);
                if (f)
                {
                    dlgCell(f, 1) dlgStringEdit(Data[f]);
                }
                else
                {
                    dlgCell(f, 1) dlgLabel(Data[f]);
                }
            }
        }

        dlgHBoxLayout
        {
            dlgStretch(1);
            dlgPushButton(tr("+OK")) dlgAccept();
            dlgPushButton(tr("-Cancel")) dlgReject();
        }
    };

    if (result)
    {
        for (int f = 0; f < Fields; f++)
            Data[f] = StripWhiteSpace(Data[f]);

        Database[Entry] = strjoin(Data, DatabaseSeparator);
        DatabaseModified = 1;

        GenerateList();
     }
}

void EditDatabase(void)
{
    if (Database[0])
    {
        if (Selected)
        {
            string a[];
            int KeyField = strsplit(a, Lines[0], '\t');
            strsplit(a, Lines[Selected], '\t');
            string key = a[KeyField];
            string data;
            int entry;

            for (entry = 0; Database[entry]; entry++)
            {
                strsplit(a, Database[entry], DatabaseSeparator);
                if (a[0] == key)
                {
                    data = Database[entry];
                    break;
                }
            }
            EditDatabaseEntry(key, entry);
        }
        else
        {
            dlgMessageBox(tr("Please select a list entry first!"));
        }
    }
    else
    {
        dlgMessageBox(tr("Please load a database file first!"));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Allow user to edit the part number data for a part

int nPickSel = 0;

numeric string PickView[];
numeric string PickLine;

numeric string PickPartNum;
numeric string PickPartVal;

string GetDatabaseRecord(int row)
{
    string s;
    string a[];

    int n = strsplit(a, Database[row], DatabaseSeparator);
    int i;

    for (i=0; i < n; i++)
        s += a[i] + "\t";

    s = strsub(s, 0, strlen(s) - 1);

    return s;
}

string GetDatabaseField(int row, int col)
{
    int n;
    string s;
    string a[];
    n = strsplit(a, Database[row], DatabaseSeparator);
    if (col < n)
        s = a[col];
    return s;
}

void OnPickSelChanged()
{
    PickPartNum = GetDatabaseField(nPickSel, 0);
}
                    
void EditPartEntry(string partname)
{
    int ndx = PartSearch(partname);

    if (ndx == -1)
    {
        string msg;
        sprintf(msg, "Error - part ID '%s' not found!", partname);
        dlgMessageBox(msg, "OK");
        return;
    }

    // this call is needed to load the database header fields
    DatabaseHeader();
    
    PartNumPicked = 0;
    PickPartNum = PartNum[ndx];
    PickPartVal = PartVal[ndx];

    int result;

    if (Database[0])
    {
        int i;
        int count = 0;

        // Fill the pick listview with all of the database records
        for (i=0; i < DatabaseRecCount; i++)
            PickView[count++] = GetDatabaseRecord(i);


        // Set the list selection to the current part number if possible

        nPickSel = 0;

        for (i=0; i < DatabaseRecCount; i++)
        {
            string a[];
            strsplit(a, Database[i], DatabaseSeparator);
            if (PickPartNum == a[0])
            {
                nPickSel = i;
                break;
            }
        }

        result = dlgDialog("Pick Part")
        {
            dlgHBoxLayout dlgSpacing(500);
            dlgHBoxLayout
            {
                dlgVBoxLayout dlgSpacing(300);
                dlgListView("", PickView, nPickSel)
                {
                    if (dlgSelectionChanged())
                        OnPickSelChanged();
                    else
                        dlgAccept();    // double click
                }
            }
            dlgHBoxLayout
            {
                dlgLabel("Part Number:");
                dlgStringEdit(PickPartNum);
                dlgLabel("Part Value:");
                dlgStringEdit(PickPartVal);
                dlgStretch(1);
                dlgPushButton("&OK") dlgAccept();
                dlgPushButton("-Cancel")  dlgReject();
            }
        };

        if (result)
        {
            // User clicked OK, save the part number and any optional new
            // part value that needs to be assigned to the part.
            
            PickPartNum = StripWhiteSpace(PickPartNum);
            PickPartVal = StripWhiteSpace(PickPartVal);
            
            PartNumPicked = 1;
            PartNum[ndx] = PickPartNum;
            PartVal[ndx] = PickPartVal;

            PartNumModified = 1;

            GenerateList();
         }
    }
    else
    {
        result = dlgDialog("Part Number Manager")
        {
            dlgHBoxLayout
            {
                dlgGroup("Edit Part Number")
                {
                    dlgGridLayout
                    {
                        dlgCell(0, 0) dlgLabel("Part Name:");
                        dlgCell(0, 1) dlgLabel(partname);

                        dlgCell(1, 0) dlgLabel("Part Value:");
                        dlgCell(1, 1) dlgStringEdit(PickPartVal);

                        dlgCell(2, 0) dlgLabel("Part Package:");
                        dlgCell(2, 1) dlgLabel(PartPkg[ndx]);

                        dlgCell(3, 0) dlgLabel("Part Number:");
                        dlgCell(3, 1) dlgStringEdit(PickPartNum);
                    }
                }
                dlgVBoxLayout
                {
                    dlgStretch(2);
                    dlgPushButton("+OK") dlgAccept();
                    dlgPushButton("-Cancel") dlgReject();
                }
            }
        };

        if (result)
        {
            PickPartNum = StripWhiteSpace(PickPartNum);

            PartNumPicked = 1;
            PartNum[ndx] = PickPartNum;
            PartVal[ndx] = PickPartVal;

            PartNumModified = 1;

            GenerateList();
         }
    }
}

void EditPart(void)
{
    if (nPartCount)
    {
        if (Selected)
        {
            // NOTE: THE VIEW COL NUM FOR a[n] MUST CORRESPOND TO THE PART ID
            string a[];
            strsplit(a, Lines[Selected], '\t');
            // Column 1 Lines[] contains the part-id!
            string partname = a[0];
            // we have to strip off any (DNP) suffix from the part name
            partname = TrimDNPSuffix(partname);
            EditPartEntry(partname);
        }
        else
        {
            dlgMessageBox("Please select a part from the list!");
        }
    }
    else
    {
        dlgMessageBox("No Parts Found!");
    }
}

void EditPartSet(void)
{
    if (ListType == 0)
        EditPart();
    else
    {
        if (nPartCount)
        {
            if (Selected)
            {
                // NOTE: THE VIEW COL NUM FOR a[n] MUST CORRESPOND TO THE PART ID
                string a[];
                string b[];
                strsplit(a, Lines[Selected], '\t'); // Column 5 Lines[] contains the part-id!
                int n = strsplit(b, a[4], ','); // First part in list
                string partname = b[0];
                // we have to strip off any (DNP) suffix from the part name
                partname = TrimDNPSuffix(partname);
                EditPartEntry(partname);
                
                int pt0 = PartSearch(partname);
                if (PartNumPicked && (n>1) && (pt0>-1))
                {
                    for(int i=1; i<n; i++)
                    {
                        partname = b[i];
                        partname = StripWhiteSpace(partname);
                        partname = TrimDNPSuffix(partname);
                        
                        int ndx = PartSearch(partname);
                        //partname += "|";
                        //dlgMessageBox(partname);
                        if(ndx>-1)
                        {
                            PartNum[ndx] = PartNum[pt0];    
                            PartVal[ndx] = PickPartVal; //[pt0];
                        }
                        GenerateList();
                    }
           
                }
            }
            else
            {
                dlgMessageBox("Please select a part from the list!");
            }
        }
        else
        {
            dlgMessageBox("No Parts Found!");
        }
    }
}
        
//////////////////////////////////////////////////////////////////////////////
// The part database requires the following database fields to support
// exporting supplier BOM order files. Additionally, the first column
// must always contain the manufacturer part number. You may add additional
// fields to the database record stucture, but the following fields are
// required and must be named as follows (except those marked as optional).
//
//  Col   Field Name                    Description
//  -------------------------------------------------------------------
//   0    "Part Num"            PARTNUM key for schematic
//   1    "Mfg Name"            Manufacurer name for the part
//   2    "VID"                 "DK" for Digikey Corp
//                              "ME" for Mouser Electronics
//                              "AE" for Allied Electronics
//   3    "Vendor Part Num"     Specifies DigiKey part number
//   4    "Description"         Optional - nice to have
//   5    "Qty 1"               Optional - auto-generated if not defined
//   6    "Qty 2"               First bulk order quantity
//   7    "Qty 3"               Second bulk order quantity
//   8    "Customer Ref"        Customer reference number
//
// Note that the "Qty 1" field is calculated automatically from the number
// of parts in schematic and specifies the qty required to build a single unit.
//
// The "Qty 2" and "Qty 3" fields are user specified bulk quantities
// that will be generated in the order upload file.
//

string BOMDatabaseLookup(string key, string field)
{
    // First make sure the field name exists in header. If not we
    // don't attempt to lookup or we'll get an error message dialog
    // from Eagle and the ulp will terminate.

    string a[];
    int n = strsplit(a, Database[0], DatabaseSeparator);
    int found = 0;
    for (int i=0; i < n; i++)
    {
        if (field == a[i])
        {
            found = 1;
            break;
        }
    }

    if (!found)
        return nullKey;

    // Field name exists, attempt to lookup the key

    string val = lookup(Database, key, field, DatabaseSeparator);

    if (!val || (val == field))
        val = nullKey;

    return val;
}

//////////////////////////////////////////////////////////////////////////////
// Export a generic BOM parts order file for all parts.

int ExportGeneric()
{
    int csvflag = 1;

    int result = dlgDialog(tr("Export Generic Parts Order"))
    {
        dlgHBoxLayout
        {
            dlgGroup(tr("Export BOM Format"))
            {
                dlgRadioButton(tr("&TAB delimited text format"), csvflag);
                dlgRadioButton(tr("&CSV comma separated fields"), csvflag);
            }
            dlgVBoxLayout
            {
                dlgStretch(1);
                dlgPushButton(tr("+OK")) dlgAccept();
                dlgPushButton(tr("-Cancel")) dlgReject();
            }
        }
    };

    if (!result)
        return -1;

    string fname;
    string extname = (csvflag) ? ".csv" : ".txt";
    string delimit = (csvflag) ?  "," : "\t";

    fname = filesetext(ConfigFilePath+DefaultFileName, "_GenericPartsOrder"+extname);

    fname = dlgFileSave(tr("Export BOM"), fname, tr("BOM files (*") + extname + tr(");;All files (*)"));

    if (!fname)
        return -1;
    if (fileext(fname) != extname)
        fname += extname;

    fileerror();

    int records = 0;

    output(fname, "wt")
    {
        int fcount, i;
        int i1, n1, n2;
        int numlines = 0;
        int index[];

        // print out the inital header line of the column descriptions
        // for all database header fields.

        string fields[];

        fcount = strsplit(fields, Database[0], DatabaseSeparator);

        for (i=0; i < fcount; i++)
        {
            printf(fields[i]);

            if (i < fcount-1)
                printf(delimit);
        }

        printf("%sQty1%sQty2%sQty3%sPart References", delimit, delimit, delimit, delimit);
        printf("\n");

        // sort by part value
        //sort(nPartCount, index, PartVal, PartNum, PartDev, PartName);
        // [RES125] - Changed sort order
        sort(nPartCount, index, PartName, PartVal, PartPkg);

        for (n1=0, n2=0; ++n2 <= nPartCount;)
        {
            i1 = index[n1];

            if (n2 < nPartCount)
            {
                int i2 = index[n2];
                // check for same value but different partnum
                if ((PartVal[i1] == PartVal[i2]) && (PartDev[i1] == PartDev[i2]))
                {
                    if (strlen(PartNum[i1]) && strlen(PartNum[i2]))
                    {
                        if (PartNum[i1] == PartNum[i2])
                            continue;
                    }
                    else
                    {
                        continue;
                    }
                }
            }

            // Calculate the qty of parts needed to build one unit.
            int uqty = n2 - n1;

            // Build a list of all part reference designators to this part number
            // for debugging purposes in case a part number is not specified or
            // the part number lookup fails. We dump all the part refs in case
            // of an error so we can figure out which items have bad partno's.

            numeric string partnames;

            for (;;)
            {
                partnames += PartName[i1];

                // Skip do not place (DNP) parts
                if (PartDNP[i1])
                {
                    partnames += dnpSuffix;

                    if (uqty)
                        -- uqty;
                }

                ++n1;

                if (n1 < n2)
                {
                    i1 = index[n1];
                    partnames += "/";
                }
                else
                    break;
            }

            // Look up the supplier part number from mfg part number, column
            // zero should always be the manufacturer part number key

            int errflag = 0;

            string partno_key = PartNum[i1];

            if (!partno_key)
            {
                printf("*** ERROR - MISSING 'PARTNO' ATTRIBUTE: %s\n", PartName[i1]);
            }
            else
            {
                string item = BOMDatabaseLookup(partno_key, fields[0]);

                numeric string quantity1;
                numeric string quantity2;
                numeric string quantity3;

                sprintf(quantity1, "%d", uqty * BldQty1);
                sprintf(quantity2, "%d", uqty * BldQty2);
                sprintf(quantity3, "%d", uqty * BldQty3);

                if (!item || (item == nullKey))
                {
                    printf("*** ERROR - PART '%s' NOT FOUND FOR: %s\n", partno_key, partnames);
                }
                else
                {
                    printf("%s%s", partno_key, delimit);

                    for (i=1; i < fcount; i++)
                    {
                        string item = BOMDatabaseLookup(partno_key, fields[i]);

                        printf("%s", item);

                        if (i < fcount-1)
                            printf(delimit);
                    }

                    printf("%s%s%s%s%s%s%s%s", delimit, quantity1, delimit, quantity2, delimit, quantity3, delimit, partnames);

                    printf("\n");

                    records++;
                }
            }

            numlines++;
        }
    };

    if (fileerror())
        dlgMessageBox(tr("A file error occured!"));

    return records;
}

//////////////////////////////////////////////////////////////////////////////
// Export a Digi-Key format upload BOM in CSV or TAB format
//
// Note that the "Qty 1" field is calculated automatically from the number
// of parts in schematic and specifies the qty required to build a single unit.
//
// The "Qty 2" and "Qty 3" fields are user specified bulk quantities
// that will be generated in the order upload file.
//
// VID must be set to "DK"

string strDKFields[] = {
    "Digi-Key Part No.",          // field 0
    "Manufacturer Name",          // field 1
    "Mfr Part No.",               // field 2
    "Customer Reference",         // field 3
    "Qty1",                       // field 4
    "Qty2",                       // field 5
    "Qty3",                       // field 6
    ""                            // null
};

int ExportDigiKey()
{
    int csvflag = 1;

    int result = dlgDialog(tr("Export Digi-Key Parts Order"))
    {
        dlgHBoxLayout
        {
            dlgGroup(tr("Export Digi-Key BOM Format"))
            {
                dlgRadioButton(tr("&TAB delimited text format"), csvflag);
                dlgRadioButton(tr("&CSV comma separated fields"), csvflag);
            }
            dlgVBoxLayout
            {
                dlgStretch(1);
                dlgPushButton(tr("+OK")) dlgAccept();
                dlgPushButton(tr("-Cancel")) dlgReject();
            }
        }
    };

    if (!result)
        return -1;

    string fname;
    string extname = (csvflag) ? ".csv" : ".txt";
    string delimit = (csvflag) ?  "," : "\t";

    fname = filesetext(ConfigFilePath+DefaultFileName, "_DigiKeyOrder"+extname);

    fname = dlgFileSave(tr("Export Digi-Key BOM"), fname, tr("BOM files (*") + extname + tr(");;All files (*)"));

    if (!fname)
        return -1;

    if (fileext(fname) != extname)
        fname += extname;

    fileerror();

    int records = 0;

    output(fname, "wt")
    {
        int i, i1, n1, n2;
        int numlines = 0;
        int index[];

        // print out the inital header line of the column descriptions
        printf("%s\n", strjoin(strDKFields, delimit[0]));

        // sort by part value
        //sort(nPartCount, index, PartVal, PartNum, PartDev, PartName);
        // [RES125] - Changed sort order
        sort(nPartCount, index, PartName, PartVal, PartPkg);

        for (n1=0, n2=0; ++n2 <= nPartCount;)
        {
            i1 = index[n1];

            if (n2 < nPartCount)
            {
                int i2 = index[n2];
                // check for same value but different partnum
                if ((PartVal[i1] == PartVal[i2]) && (PartDev[i1] == PartDev[i2]))
                {
                    if (strlen(PartNum[i1]) && strlen(PartNum[i2]))
                    {
                        if (PartNum[i1] == PartNum[i2])
                            continue;
                    }
                    else
                    {
                        continue;
                    }
                }
            }

            // Calculate the qty of parts needed to build one unit.
            int uqty = n2 - n1;

            // Build a list of all part reference designators to this part number
            // for debugging purposes in case a part number is not specified or
            // the part number lookup fails. We dump all the part refs in case
            // of an error so we can figure out which items have bad partno's.

            numeric string partnames;

            for (;;)
            {
                partnames += PartName[i1];

                // Skip do not place (DNP) parts
                if (PartDNP[i1])
                {
                    if (uqty)
                        -- uqty;
                }

                if (++n1 < n2)
                {
                    i1 = index[n1];
                    partnames += "/";
                }
                else
                    break;
            }

            if (!uqty)
                continue;

            // Look up the supplier part number from mfg part number, column
            // zero should always be the manufacturer part number key

            int errflag = 0;

            string part_num = PartNum[i1];
            string partno_dk;
            string cust_ref;
            string vendor_id;
            string mfg_name;
            numeric string quantity1;
            numeric string quantity2;
            numeric string quantity3;

            if (!part_num)
            {
                printf("*** ERROR - MISSING 'PARTNO' ATTRIBUTE: %s\n", PartName[i1]);
            }
            else
            {
                // Look up vendor part number in database from the mfg part number.
                partno_dk = BOMDatabaseLookup(part_num, "Vendor Part Num");

                if (partno_dk == nullKey)
                    errflag = 1;

                // Lookup the customer reference number for this part
                cust_ref  = BOMDatabaseLookup(part_num, "Customer Ref");

                if (cust_ref == nullKey)
                    cust_ref = partnames;

                // Lookup the vendor ID based on the mfg part number - must be "DK"
                vendor_id = BOMDatabaseLookup(part_num, "VID");

                // Lookup the manufacturer name based on the mfg part number
                mfg_name  = BOMDatabaseLookup(part_num, "Mfg Name");

                // Lookup first bulk quantity value
                quantity1 = BOMDatabaseLookup(part_num, "Qty 1");
                if (quantity1 == nullKey)
                {
                    sprintf(quantity1, "%d", uqty * BldQty1);
                }

                // Lookup second bulk quantity value
                quantity2 = BOMDatabaseLookup(part_num, "Qty 2");
                if (quantity2 == nullKey)
                {
                    sprintf(quantity2, "%d", uqty * BldQty2);
                }

                // Lookup third bulk quantity value
                quantity3 = BOMDatabaseLookup(part_num, "Qty 3");
                if (quantity3 == nullKey)
                {
                    sprintf(quantity3, "%d", uqty * BldQty3);
                }
            }

            // Only output parts with DigiKey vendor id "DK"

            if ((vendor_id == "DK") || (vendor_id == "*"))
            {
                printf("%s%s", partno_dk, delimit);
                printf("%s%s", mfg_name, delimit);
                printf("%s%s", part_num, delimit);
                printf("%s%s", cust_ref, delimit);
                printf("%s%s", quantity1, delimit);
                printf("%s%s", quantity2, delimit);
                printf("%s%s", quantity3, delimit);

                if (errflag)
                    printf(" *** ERROR : %s", partnames);

                printf("\n");

                records++;
            }

            numlines++;
        }
    };

    if (fileerror())
        dlgMessageBox(tr("A file error occured!"));

    return records;
}

//////////////////////////////////////////////////////////////////////////////
// Export a Allied Electronics BOM formatted file in text format.
//
// VID must be set to "AE"
//

string strAEFields[] = {
    "Allied Part Number",         // field 0
    "Manufacturer Name",          // field 1
    "Mfr Part No.",               // field 2
    "Customer Reference",         // field 3
    "Qty1",                       // field 4
    "Qty2",                       // field 5
    "Qty3",                       // field 6
    ""                            // null
};

int ExportAllied()
{
    int csvflag = 1;

    int result = dlgDialog(tr("Export Allied Parts Order"))
    {
        dlgHBoxLayout
        {
            dlgGroup(tr("Export Allied BOM Format"))
            {
                dlgRadioButton(tr("&TAB delimited text format"), csvflag);
                dlgRadioButton(tr("&CSV comma separated fields"), csvflag);
            }
            dlgVBoxLayout
            {
                dlgStretch(1);
                dlgPushButton(tr("+OK")) dlgAccept();
                dlgPushButton(tr("-Cancel")) dlgReject();
            }
        }
    };

    if (!result)
        return -1;

    string fname;
    string extname = (csvflag) ? ".csv" : ".txt";
    string delimit = (csvflag) ?  "," : "\t";

    fname = filesetext(ConfigFilePath+DefaultFileName, "_AlliedOrder"+extname);

    fname = dlgFileSave(tr("Export Digi-Key BOM"), fname, tr("BOM files (*") + extname + tr(");;All files (*)"));

    if (!fname)
        return -1;

    if (fileext(fname) != extname)
        fname += extname;

    fileerror();

    int records = 0;

    output(fname, "wt")
    {
        int i, i1, n1, n2;
        int numlines = 0;
        int index[];

        // print out the inital header line of the column descriptions
        printf("%s\n", strjoin(strAEFields, delimit[0]));

        // sort by part value
        //sort(nPartCount, index, PartVal, PartNum, PartDev, PartName);
        // [RES125] - Changed sort order
        sort(nPartCount, index, PartName, PartVal, PartPkg);

        for (n1=0, n2=0; ++n2 <= nPartCount;)
        {
            i1 = index[n1];

            if (n2 < nPartCount)
            {
                int i2 = index[n2];
                // check for same value but different partnum
                if ((PartVal[i1] == PartVal[i2]) && (PartDev[i1] == PartDev[i2]))
                {
                    if (strlen(PartNum[i1]) && strlen(PartNum[i2]))
                    {
                        if (PartNum[i1] == PartNum[i2])
                            continue;
                    }
                    else
                    {
                        continue;
                    }
                }
            }

            // Calculate the qty of parts needed to build one unit.
            int uqty = n2 - n1;

            // Build a list of all part reference designators to this part number
            // for debugging purposes in case a part number is not specified or
            // the part number lookup fails. We dump all the part refs in case
            // of an error so we can figure out which items have bad partno's.

            numeric string partnames;

            for (;;)
            {
                partnames += PartName[i1];

                // Skip do not place (DNP) parts
                if (PartDNP[i1])
                {
                    if (uqty)
                        -- uqty;
                }

                if (++n1 < n2)
                {
                    i1 = index[n1];
                    partnames += "/";
                }
                else
                    break;
            }

            if (!uqty)
                continue;

            // Look up the supplier part number from mfg part number, column
            // zero should always be the manufacturer part number key

            int errflag = 0;

            string part_num = PartNum[i1];
            string partno_dk;
            string cust_ref;
            string vendor_id;
            string mfg_name;
            numeric string quantity1;
            numeric string quantity2;
            numeric string quantity3;

            if (!part_num)
            {
                printf("*** ERROR - MISSING 'PARTNO' ATTRIBUTE: %s\n", PartName[i1]);
            }
            else
            {
                // Look up vendor part number in database from the mfg part number.
                partno_dk = BOMDatabaseLookup(part_num, "Vendor Part Num");

                if (partno_dk == nullKey)
                    errflag = 1;

                // Lookup the customer reference number for this part
                cust_ref  = BOMDatabaseLookup(part_num, "Customer Ref");

                // Lookup the vendor ID based on the mfg part number - must be "DK"
                vendor_id = BOMDatabaseLookup(part_num, "VID");

                // Lookup the manufacturer name based on the mfg part number
                mfg_name  = BOMDatabaseLookup(part_num, "Mfg Name");

                // Lookup the first bulk quantity value
                quantity1 = BOMDatabaseLookup(part_num, "Qty 1");
                if (quantity1 == nullKey)
                {
                    sprintf(quantity1, "%d", uqty * BldQty1);
                }
                // Lookup the second bulk quantity value
                quantity2 = BOMDatabaseLookup(part_num, "Qty 2");
                if (quantity2 == nullKey)
                {
                    sprintf(quantity2, "%d", uqty * BldQty2);
                }

                // Lookup the third bulk quantity value
                quantity3 = BOMDatabaseLookup(part_num, "Qty 3");
                if (quantity3 == nullKey)
                {
                    sprintf(quantity3, "%d", uqty * BldQty3);
                }
            }

            // Only output parts with DigiKey vendor id "DK"

            if ((vendor_id == "AE") || (vendor_id == "*"))
            {
                printf("%s%s", partno_dk, delimit);
                printf("%s%s", mfg_name, delimit);
                printf("%s%s", part_num, delimit);
                printf("%s%s", cust_ref, delimit);
                printf("%s%s", quantity1, delimit);
                printf("%s%s", quantity2, delimit);
                printf("%s%s", quantity3, delimit);

                if (errflag)
                    printf(" *** ERROR : %s", partnames);

                printf("\n");

                records++;
            }

            numlines++;
        }
    };

    if (fileerror())
        dlgMessageBox(tr("A file error occured!"));

    return records;
}

//////////////////////////////////////////////////////////////////////////////
// Export a Mouser Electronics BOM formatted file in text format. Currently
// the Mouser site doesn't provide a file upload feature, however it does
// let you cut/paste part numbers into a form on their website. This
// routine generates a file in this format that you can paste the results
// from.
//
// VID must be set to "ME"
//

int ExportMouser()
{
    int optqty = 0;
    int optnum = 0;

    int result = dlgDialog(tr("Export Mouser Parts Order"))
    {
        dlgHBoxLayout
        {
            dlgVBoxLayout
            {
                dlgGroup(tr("Quantity Options"))
                {
                    string qty1, qty2, qty3;

                    sprintf(qty1, "Quantity &1 (bulk qty %d)", BldQty1);
                    dlgRadioButton(qty1, optqty);

                    sprintf(qty2, "Quantity &2 (bulk qty %d)", BldQty2);
                    dlgRadioButton(qty2, optqty);

                    sprintf(qty3, "Quantity &3 (bulk qty %d)", BldQty3);
                    dlgRadioButton(qty3, optqty);
                }
                dlgGroup(tr("Create Order With"))
                {
                    dlgRadioButton(tr("Mouser Part Numbers"), optnum);
                    dlgRadioButton(tr("Manufacturer Part Numbers"), optnum);
                }
            }
        }
        dlgHBoxLayout
        {
            dlgHBoxLayout
            {
                dlgStretch(1);
                dlgPushButton(tr("+OK")) dlgAccept();
                dlgPushButton(tr("-Cancel")) dlgReject();
            }
        }
    };

    if (!result)
        return -1;

    string line;
    string fname;
    string extname = ".txt";

    //ConfigFilePath
    fname = filesetext(ConfigFilePath+DefaultFileName, "_MouserOrder"+extname);

    fname = dlgFileSave(tr("Export Mouser BOM"), fname, tr("BOM files (*") + extname + tr(");;All files (*)"));

    if (!fname)
        return -1;

    if (fileext(fname) != extname)
        fname += extname;

    fileerror();

    int records = 0;

    output(fname, "wt")
    {
        int i, i1, n1, n2;
        int numlines = 0;
        int index[];

        // sort by part value
        //sort(nPartCount, index, PartVal, PartNum, PartDev, PartName);
        // [RES125] - Changed sort order
        sort(nPartCount, index, PartNum);

        for (n1=0, n2=0; ++n2 <= nPartCount;)
        {
            i1 = index[n1];

            if (n2 < nPartCount)
            {
                int i2 = index[n2];
                // check for same value but different partnum
                if ((PartVal[i1] == PartVal[i2]) && (PartDev[i1] == PartDev[i2]))
                {
                    if (strlen(PartNum[i1]) && strlen(PartNum[i2]))
                    {
                        if (PartNum[i1] == PartNum[i2])
                            continue;
                    }
                    else
                    {
                        continue;
                    }
                }
            }

            // Calculate the qty of parts needed to build one unit.
            int uqty = n2 - n1;

            // Build a list of all part reference designators to this part number
            // for debugging purposes in case a part number is not specified or
            // the part number lookup fails. We dump all the part refs in case
            // of an error so we can figure out which items have bad partno's.

            numeric string partnames;

            for (;;)
            {
                partnames += PartName[i1];

                // Skip do not place (DNP) parts
                if (PartDNP[i1])
                {
                    if (uqty)
                        -- uqty;
                }

                if (++n1 < n2)
                {
                    i1 = index[n1];
                    partnames += "/";
                }
                else
                    break;
            }

            if (!uqty)
                continue;

            // Look up the supplier part number from mfg part number, column
            // zero should always be the manufacturer part number key

            int errflag = 0;

            string part_num = PartNum[i1];
            string partno_vendor;
            string vendor_id;
            string qty1;

            numeric string quantity1;
            numeric string quantity2;
            numeric string quantity3;

            sprintf(quantity1, "%d", n2 - n1);

            if (!part_num)
            {
                printf("*** ERROR - MISSING 'PARTNO' ATTRIBUTE: %s\n", PartName[i1]);
            }
            else
            {
                // Look up vendor part number in database from the mfg part number.
                partno_vendor = BOMDatabaseLookup(part_num, "Vendor Part Num");

                if (partno_vendor == nullKey)
                    errflag = 1;

                // Lookup the vendor ID based on the mfg part number - must be "DK"
                vendor_id = BOMDatabaseLookup(part_num, "VID");

                // If user specified qty1, use that. Otherwise use the calculated
                // quantity for the design based on the parts count.

                quantity1 = BOMDatabaseLookup(part_num, "Qty 1");
                if (quantity1 == nullKey)
                {
                    sprintf(quantity1, "%d", uqty * BldQty1);
                }

                // Lookup the first bulk quantity value
                quantity2 = BOMDatabaseLookup(part_num, "Qty 2");
                if (quantity2 == nullKey)
                {
                    sprintf(quantity2, "%d", uqty * BldQty2);
                }

                // Lookup the second bulk quantity value
                quantity3 = BOMDatabaseLookup(part_num, "Qty 3");
                if (quantity3 == nullKey)
                {
                    sprintf(quantity3, "%d", uqty * BldQty3);
                }
            }

            // Only output parts with Mouser vendor id "ME"

            if ((vendor_id == "ME") || (vendor_id == "*"))
            {
                string qty;

                if (optqty == 1)
                    qty = quantity2;
                else if (optqty == 2)
                    qty = quantity3;
                else
                    qty = quantity1;

                string partno = (optnum > 0) ? part_num : partno_vendor;

                printf("%s|%s", partno, qty);

                if (errflag)
                    printf(" *** ERROR : %s", partnames);

                printf("\n");

                records++;
            }

            numlines++;
        }
    };

    if (fileerror())
        dlgMessageBox(tr("A file error occured!"));

    return records;
}

//////////////////////////////////////////////////////////////////////////////
// Export non-empty part numbers only.
//

int ExportPartNums()
{
    int nOption;
    
    int result = dlgDialog(tr("Export Part Numbers"))
    {
        dlgGroup("Export Options")
        {
            dlgRadioButton("All part number attributes assigned in schematic", nOption);
            dlgRadioButton("Only assigned part numbers with no database match", nOption);
        }
        dlgHBoxLayout
        {
            dlgPushButton("OK") dlgAccept();
            dlgPushButton("-Cancel") dlgReject();
        }
    };

    if (!result)
        return -1;
        
    string line;
    string fname;
    string extname = ".txt";

    //ConfigFilePath
    fname = filesetext(ConfigFilePath+DefaultFileName, "_PartNums"+extname);

    fname = dlgFileSave(tr("Export Part Numbers"), fname, tr("TXT files (*") + extname + tr(");;All files (*)"));

    if (!fname)
        return -1;

    if (fileext(fname) != extname)
        fname += extname;

    fileerror();

    int records = 0;

    output(fname, "wt")
    {
        int i, i1, n1, n2;
        int numlines = 0;
        int index[];

        // sort by part value
        //sort(nPartCount, index, PartNum, PartVal);
        // [RES125] - Changed sort order
        sort(nPartCount, index, PartNum);

        for (n1=0, n2=0; ++n2 <= nPartCount;)
        {
            i1 = index[n1];

            if (n2 < nPartCount)
            {
                int i2 = index[n2];
                // check for same value but different partnum
                if ((PartVal[i1] == PartVal[i2]) && (PartDev[i1] == PartDev[i2]))
                {
                    if (strlen(PartNum[i1]) && strlen(PartNum[i2]))
                    {
                        if (PartNum[i1] == PartNum[i2])
                            continue;
                    }
                    else
                    {
                        continue;
                    }
                }
            }

            // Calculate the qty of parts needed to build one unit.
            int uqty = n2 - n1;

            // Build a list of all part reference designators to this part number
            // for debugging purposes in case a part number is not specified or
            // the part number lookup fails. We dump all the part refs in case
            // of an error so we can figure out which items have bad partno's.

            numeric string partnames;

            for (;;)
            {
                partnames += PartName[i1];

                // Skip do not place (DNP) parts
                if (PartDNP[i1])
                {
                    if (uqty)
                        -- uqty;
                }

                if (++n1 < n2)
                {
                    i1 = index[n1];
                    partnames += "/";
                }
                else
                    break;
            }

            if (!uqty)
                continue;

            // Look up the supplier part number from mfg part number, column
            // zero should always be the manufacturer part number key

            int errflag = 0;

            string part_num = PartNum[i1];
            
            if (part_num)
            {
                if (part_num != nullKey)
                {
                    if (nOption >= 1)
                    {
                        // Export only part numbers not found in the database
                        string partno_vendor;
                        
                        // Check it mfg part number exists in database
                        partno_vendor = BOMDatabaseLookup(part_num, "Mfg Part Num");

                        // If partnum not found, then write it to the file
                        if (partno_vendor == nullKey)
                        {
                            printf("%s\n", part_num);                        
                            records++;                    
                        }
                    }
                    else
                    {
                        // Export all non-null part numbers
                        printf("%s\n", part_num);
                        records++;
                    }
                }
            }

            numlines++;
        }
    };

    if (fileerror())
        dlgMessageBox(tr("A file error occured!"));

    return records;
}

//////////////////////////////////////////////////////////////////////////////
// Present the user with the build quantities desired dialog. 

int BuildQtyDialog()
{
    int result = dlgDialog(tr("BOM Order Quantities"))
    {
        dlgHBoxLayout
        {
            dlgGridLayout
            {
                dlgCell(1,0) dlgLabel("Build Units Qty1");
                dlgCell(1,1) dlgIntEdit(BldQty1, 1, 1000);

                dlgCell(2,0) dlgLabel("Build Units Qty2");
                dlgCell(2,1) dlgIntEdit(BldQty2, 1, 1000);

                dlgCell(3,0) dlgLabel("Build Units Qty3");
                dlgCell(3,1) dlgIntEdit(BldQty3, 1, 1000);
            }

            dlgVBoxLayout
            {
                dlgStretch(1);
                dlgPushButton(tr("+OK")) dlgAccept();
                dlgPushButton(tr("-Cancel")) dlgReject();
            }
        }
    };

    return result;
}

//////////////////////////////////////////////////////////////////////////////
// Main Export Dialog

int ExportBOM(void)
{
    int format = 0;

    if (!nPartCount)
    {
        dlgMessageBox(tr("No parts found!"));
        return 0;
    }

    if (!Database[0])
    {
        dlgMessageBox(tr("Please load a database file first!"));
        return 0;
    }

    int result = dlgDialog(tr("Export BOM Order File"))
    {
        dlgHBoxLayout
        {
            dlgGroup(tr("BOM Order File Format"))
            {
                dlgRadioButton(tr("&Generic Order Format"), format);
                dlgRadioButton(tr("&Digi-Key Corporation"), format);
                dlgRadioButton(tr("&Mouser Electronics"), format);
                dlgRadioButton(tr("&Allied Electronics"), format);
                dlgRadioButton(tr("&Part Numbers Attributes Only"), format);
            }
            dlgVBoxLayout
            {
                dlgStretch(1);
                dlgPushButton(tr("+OK")) dlgAccept();
                dlgPushButton(tr("-Cancel")) dlgReject();
                dlgPushButton(tr("Quantities")) BuildQtyDialog();
            }
        }
    };

    if (result)
    {
        int recs = -1;

        switch(format)
        {
        case 0:
            recs = ExportGeneric();
            break;
        case 1:
            recs = ExportDigiKey();
            break;
        case 2:
            recs = ExportMouser();
            break;
        case 3:
            recs = ExportAllied();
            break;
        case 4:
            recs = ExportPartNums();
            break;
        }

        if (recs > 1)
        {
            string tmp;
            sprintf(tmp, "%d ", recs);
            dlgMessageBox(tmp + "record item(s) were exported!", tmp);
        }
        else if (recs == 1)
            dlgMessageBox("One record item was exported!");
        else if (recs == 0)
            dlgMessageBox("No records were found for exporting!");
    }

    return result;
}

//////////////////////////////////////////////////////////////////////////////
// Save all the part number attribute data as a script
        
int WriteScriptData(string fileName)
{
    if (!fileName)
    if (fileext(fileName) != ".scr")
        fileName += ".scr";

    fileerror();

    output(fileName, "wt")
    {
        printf("CHANGE DISPLAY OFF;\n");

        for (int i=0; i < nPartCount; i++)
        {
            if (PartNum[i] != "")
            {
                printf("EDIT .s%d; ATTRIBUTE '%s' 'PARTNO' '%s';",
                    PartSheet[i], PartName[i], PartNum[i]);
            }

            // If the user has assigned a new part value different from
            // what was originally loaded, we need to apply the value
            // change to the part also.
            
            if (PartVal[i] != PartValSave[i])
                printf(" VALUE %s '%s';", PartName[i], PartVal[i]);
                
            printf("\n");
        }

        printf("EDIT .s1;\n");
    }

    PartNumModified = 0;

    return !fileerror();
}

void ApplyScriptData()
{
    string fname;

    if (dlgMessageBox("Exit and apply all part number attribute updates?", "+&OK", "-Cancel") != 0)
        return;

    schematic(SCH)
    {
        fname = filesetext(SCH.name, "_UpdatePartNumAttributes.scr");
    }

    if (!fname)
        return;

    if (!WriteScriptData(fname))
        return;

    string cmd;
    sprintf(cmd, "SCRIPT '%s';\n", fname);
    exit(cmd);
}

int SaveScriptData()
{
    if (!nPartCount)
    {
        dlgMessageBox("No part data exists!");
        return 0;
    }

    string fileName = "";

    schematic(SCH)
    {
        fileName = filesetext(SCH.name, "_UpdatePartNumAttributes.scr");
    }

    fileName = dlgFileSave("Save Script file", fileName, "Script files (*.scr);;All files (*)");

    if (!fileName)
        return 0;

    if (fileext(fileName) != ".scr")
        fileName += ".scr";

    return WriteScriptData(fileName);
}

//////////////////////////////////////////////////////////////////////////////
// This function allows the user to import a TAB delimited text file
// that contains part ID and manufacturer part number information.

string txtImportHlp = "This function allows importing a tabbed text delimited file "
    "that contains part ID and part number key information. This feature is "
    "useful for assigning part number attributes from existing external BOM data "
    "for BOM-EX usage. The import file data must be in the following format:\n\n"
    "  Part Name\t\tPart Number\n"
    "  R4\t\tMCR10EZHJ000\n"
    "  R21\t\tERA-6YEB101V\n"
    "  R12\t\tERA-6YEB391V\n"
    "  \"R3, R20\"\t\tERJ-6ENF1001V\n"
    "  R13\t\tERJ-6ENF1241V\n"
    "  R1\t\tERJ-6ENF2211V\n"
    "  \"R5, R7, R10, R25\"\tERJ-6ENF4751V\n\n"
    "Note the first line containing \"Part Name\" and \"Part Number\" is the "
    "header line. The names in these columns don't really matter but the "
    "header and all other data records must have TAB delimiters for the "
    "record field delimiters.\n\n"
    "The \"Part Name\" fields may contain multiple part name designators, but "
    "each part id must be delimited by a comma. If multiple part name designators "
    "are contained on a line, it should have quotes around the entire part id "
    "names string (default Excel format for tabbed text).";

int ImportPartNums()
{
    int rtn;
    
    rtn = dlgDialog(tr("Import Part Numbers"))
    {
        dlgHBoxLayout dlgSpacing(650);
        dlgHBoxLayout
        {
            dlgVBoxLayout dlgSpacing(300);
            dlgTextView(txtImportHlp);
        }
        dlgHBoxLayout
        {
            dlgStretch(1);
            dlgPushButton(tr("+OK")) dlgAccept();            
            dlgPushButton(tr("-Cancel")) dlgReject();
        }
    };
    
    if (rtn <= 0)
        return 0;

    string fileName;
    string data[];
    int numlines;

    schematic(SCH)
    {
        fileName = filesetext(SCH.name, ".txt");
    }

    fileName = dlgFileOpen("Import Part Name Numbers", fileName, "Import part number files (*.txt);;All files (*)");

    if (!fileName)
        return 0;

    if ((numlines = fileread(data, fileName)) > 0)
    {
        for (int i=1; i < numlines; i++)
        {
            int n;
            string cols[];

            if ((n = strsplit(cols, data[i], '\t')) == 2)
            {
                string partids = TrimQuotes(cols[0]);
                string partnum = StripWhiteSpace(cols[1]);

                string id[];
                n = strsplit(id, partids, ',');

                for (int j=0; j < n; j++)
                {
                    string partid = StripWhiteSpace(id[j]);

                    int ndx = PartSearch(partid);

                    if (ndx >= 0)
                        PartNum[ndx] = partnum;
                }
            }
        }

        PartNumModified = 1;

        GenerateList();

        dlgRedisplay();

        return 1;
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//

int OkToClose(void)
{
    if (DatabaseModified)
    {
        switch (dlgMessageBox(tr("Database has been modified\n\nSave Database?"), tr("+&Yes"), tr("&No"), tr("-Cancel")))
        {
        case 0: return SaveDatabase();
        case 1: break;
        case 2: return 0;
        }
    }
    if (PartNumModified)
    {
        int rtn = dlgMessageBox("Part numbers have been added or modified\n\nSave Script?", "+&Yes", "&No", "-Cancel");
        switch (rtn)
        {
        case 0: return SaveScriptData();
        case 1: break;
        case 2: return 0;
        }
    }
    return 1;
}

void DisplayHelp(void)
{
    dlgDialog(tr("Bill Of Material - Help"))
    {
        dlgHBoxLayout dlgSpacing(650);
        dlgHBoxLayout
        {
            dlgVBoxLayout dlgSpacing(300);
            dlgTextView(language() == "de" ? HelpTextDE : HelpTextEN);
        }
        dlgHBoxLayout
        {
            dlgStretch(1);
            dlgPushButton(tr("-Close")) dlgReject();
        }
    };
}

void OnListComboSelChange()
{
    if (ListType == 0)
        GeneratePartList();
    else
        GenerateValueList();

    Selected = 0;
}

void OnClickListView()
{
    if (ListType == 0)
        EditPart();
    else
        EditPartSet();
}

// MAIN SCRIPT EXECUTION ENTRY POINT //////////////////////////////

if (!schematic)
{
    dlgMessageBox(usage + tr("<hr><b>ERROR: No schematic!</b><p>\nThis program can only work in the schematic editor."));
    exit(1);
}
else
{
    // load the last file open directory path saved
    string rf[];

    int nrf = fileglob(rf, filedir(argv[0])+ConfigFileName);

    if (nrf)
        nrf = fileread(ConfigFilePath, rf[0]);

    DatabaseFilename = ConfigFilePath;

    schematic(SCH)
    {
        DefaultFileName = filename(SCH.name);

        // Check global attributes for DATABASE name to auto-load.
        // If the name begins with a period, then treat the path
        // as relative to the base schematic project directory.
        // Otherwise, assume the global name specfies a full path.

        SCH.attributes(A)
        {
            if (A.name == "DATABASE")
            {
                string fname = A.value;
                if (fname[0] == '.')
                {
                    string tmp = fname;
                    for (int i=0; i < strlen(tmp)-2; i++)
                        fname[i] = tmp[i+2];
                    fname[i] = 0;
                    fname = filedir(SCH.name) + fname;
                }
                LoadDatabase(fname);
                break;
            }
        }
    }

    CollectPartData();

    GenerateList();

    dlgDialog(tr("BOM-EX v") + strVersion)
    {
        dlgHBoxLayout
        {
            dlgLabel(tr("Database:"));
            dlgLabel(DatabaseFilename, 1);
            dlgStretch(1);
            dlgPushButton(tr("E&dit")) if (OkToClose()) EditDatabase();
            dlgPushButton(tr("&Load")) if (OkToClose()) LoadDatabase("");
            dlgPushButton(tr("&New"))  if (OkToClose()) NewDatabase();
            dlgPushButton(tr("H&elp")) DisplayHelp();
        }

        dlgHBoxLayout dlgSpacing(600);

        dlgListView("", Lines, Selected) OnClickListView();

        dlgHBoxLayout
        {
            dlgHBoxLayout
            {
                dlgLabel(tr("List by:"));
                string comboView[] = { "Parts", "Values" };
                dlgComboBox(comboView, ListType) OnListComboSelChange();

                dlgLabel(tr("Format:"));
                string comboFmt[] = { "Text", "HTML" };
                dlgComboBox(comboFmt, OutputFormat);
            }

            dlgHBoxLayout
            {
                dlgStretch(1);
                dlgPushButton(tr("&Assign Part#")) EditPartSet();
                dlgPushButton(tr("I&mport Part#")) ImportPartNums();
                dlgPushButton(tr("E&xport BOM")) ExportBOM();
                dlgPushButton(tr("&Save BOM")) SaveBOM();
                dlgPushButton(tr("Sa&ve Script")) SaveScriptData();
                dlgPushButton(tr("&Apply All")) ApplyScriptData();
                dlgPushButton(tr("+Previe&w")) ViewList();
                dlgPushButton(tr("-Close")) if (OkToClose()) dlgAccept();
             }
        }
    };
}

// End-Of-File

